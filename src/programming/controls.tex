One of our biggest weaknesses in previous years was with the driver's
mastery (or lack thereof) over our robot's controls. No matter how well
the robot was designed, it was ultimately held back by a lack of driver
familiarity with the control systems. We aimed to avoid this issue this
year by investing heavily into the driver's controls.

\subsubsection{Drive modes and the gear selector}

One of our major developments was the gear/drive mode selector system
(these terms may be used interchangeably throughout this paper). With
clear and distinct ``gears'' separating each of our operating modes,
mental stress on the driver is vastly reduced, as they no longer have to
think about whether they have some feature like ``reverse enabled'', but
instead can simply think about what ``gear'' they are in. This subtle
but important paradigm shift allows the driver to easily choose the
right settings to fulfill their current needs without thinking about
convoluted control schemes. \\

% TODO: talk more about the drive modes and their implementation in
% code, and their streaming via network tables
\blindtext{}

\subsubsection{Dashboard}

Something we worked on this season which many FRC teams often overlook
was the driver dashboard. An amazing robot and control scheme mean
nothing if vital information is not quickly and intuitively conveyed to
the driver. With this in mind, we set out to design our own dashboard
which was tightly integrated with our specific robot controls and
features to bring out their fullest potential, dubbed the ``Jankboard''.
Despite being christened after the term ``jank,'' the Jankboard is
anything but. It has a full 3D driver visualization that automatically
syncs and updates with the real-time status of the robot, and responds
to user actions like changing drive or speed modes. It also warns the
user of imminent collision, and reports useful telemetry information
like speed, heading, etc. \\

Jankboard is one of our only programming projects not made with Java.
Its frontend is build using the Svelte framework and TypeScript, and its
backend which handles calculations and telemetry uplink with our robot
is written in Rust, using a custom FRC NetworkTables v4 implementation.
